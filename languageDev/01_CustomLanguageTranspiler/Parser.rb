# Require the Nodes file, which defines various node structures (e.g., DefNode, CallNode, IntegerNode, VarRefNode)
require "./Nodes.rb"

# The Parser class is responsible for transforming a list of tokens into an Abstract Syntax Tree (AST).
class Parser
  # Initializes the parser with a list of tokens to be parsed.
  # @param tokens [Array] an array of Token objects generated by the tokenizer.
  def initialize(tokens)
    @tokens = tokens
  end

  # Main entry point to begin parsing a function definition.
  # This method assumes the tokens start with a 'def' keyword for a function.
  # @return [DefNode] the root of the AST representing the function definition.
  def parse
    parse_def
  end

  # Consumes the next token if it matches the expected type; otherwise, raises an error.
  # @param expected_type [Symbol] the expected type of the next token.
  # @return [Token] the consumed token if it matches the expected type.
  def consume(expected_type)
    token = @tokens.shift                            # Remove and return the next token
    if token.type == expected_type                   # Check if it matches the expected type
      token                                          # Return token if types match
    else
      # Raise an error if the token type doesn't match the expected type
      raise RuntimeError.new("Expected token type #{expected_type.inspect}, but got #{token.type.inspect}!")
    end
  end

  # Peeks at the next token type without consuming it, useful for lookahead.
  # @param expected_type [Symbol] the type to check for.
  # @param offset [Integer] the position in the token list to check (default is 0, the next token).
  # @return [Boolean] true if the token at the specified offset matches the expected type.
  def peek(expected_type, offset=0)
    @tokens.fetch(offset).type == expected_type
  end

  # Parses a function definition with a name, arguments, and body.
  # Expected syntax: def <name>(<args>) <body> end
  # @return [DefNode] a node representing the parsed function definition.
  def parse_def
    consume(:def)                              # Expect and consume the 'def' keyword
    name = consume(:identifier).value          # Get the function name (identifier)
    arg_names = parse_arg_names                # Parse function arguments
    body = parse_expr                          # Parse the function body
    consume(:end)                              # Expect and consume the 'end' keyword
    DefNode.new(name, arg_names, body)         # Return a DefNode representing the function
  end

  # Parses argument names inside parentheses for a function.
  # Expected syntax: (<arg1>, <arg2>, ...)
  # @return [Array<String>] a list of argument names.
  def parse_arg_names
    arg_names = []
    consume(:oparen)                           # Expect and consume '('
    if peek(:identifier)                       # Check if there are any arguments
      arg_names << consume(:identifier).value  # Consume first argument name
      while peek(:comma)                       # While commas are present, there are more arguments
        consume(:comma)                        # Consume comma
        arg_names << consume(:identifier).value # Consume subsequent argument names
      end
    end
    consume(:cparen)                           # Expect and consume ')'
    arg_names                                  # Return list of argument names
  end

  # Determines the type of the current expression (integer, function call, or variable reference)
  # and delegates to the appropriate parsing method.
  # @return [Node] the parsed expression node.
  def parse_expr
    if peek(:integer)                          # If token is an integer
      parse_int                                # Parse as an integer node
    elsif peek(:identifier) && peek(:oparen, 1)
      parse_call                               # Parse as a function call if an identifier is followed by '('
    else
      parse_var_ref                            # Otherwise, parse as a variable reference
    end
  end

  # Parses an integer value and returns an IntegerNode.
  # Expected syntax: <integer>
  # @return [IntegerNode] a node representing the integer value.
  def parse_int
    IntegerNode.new(consume(:integer).value.to_i) # Consume integer and convert to IntegerNode
  end

  # Parses a function call expression.
  # Expected syntax: <name>(<arg_exprs>)
  # @return [CallNode] a node representing the function call with arguments.
  def parse_call
    name = consume(:identifier).value          # Get the function name
    arg_exprs = parse_arg_exprs                # Parse argument expressions
    CallNode.new(name, arg_exprs)              # Return a CallNode representing the function call
  end

  # Parses a list of argument expressions within parentheses.
  # Expected syntax: (<expr1>, <expr2>, ...)
  # @return [Array<Node>] a list of expression nodes representing each argument.
  def parse_arg_exprs
    arg_exprs = []
    consume(:oparen)                           # Expect and consume '('
    if !peek(:cparen)                          # If there is no closing parenthesis, there are arguments to parse
      arg_exprs << parse_expr                  # Parse first argument expression
      while peek(:comma)                       # While commas are present, there are more arguments
        consume(:comma)                        # Consume comma
        arg_exprs << parse_expr                # Parse subsequent argument expressions
      end
    end
    consume(:cparen)                           # Expect and consume ')'
    arg_exprs                                  # Return list of argument expressions
  end

  # Parses a variable reference expression.
  # Expected syntax: <variable>
  # @return [VarRefNode] a node representing the variable reference.
  def parse_var_ref
    VarRefNode.new(consume(:identifier).value) # Consume identifier and convert to VarRefNode
  end
end
